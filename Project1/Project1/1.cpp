//枚举---一枚一枚取出来试


//算法


//程序执行

//解释：接著一个程序，那个程序能试图理解你的程序，
//然后按照你的要求执行

//编译：借助一个程序，就像一个翻译，把你的程序翻译成
//计算机真正能懂的语言--机器语言--写的程序，然后这个
//机器语言写的程序就能直接执行了

//语言都是相通的 


//version

//1989 --- ANSI C
//1990 --- C89
//1995 --- c95
//1999 --- c99   (变量可以在任意的地方定义,可以有const)


//C语言需要被编译才能执行 
//需要:
//	编辑器(代码敲进去，记录代码)
//	编译器(将代码变成计算机能懂的东西)
//	或者，IDE(集成开发环境)



//计算机会一步一步照着代码做

#include<stdio.h>




void plus()
{
	int a;
	int b;
	int c;
	printf("输入两个整数X+Y\n");
	scanf_s("%d+%d", &a, &b);
	//输入时要输入    a的值+b的值，和“”中的格式要一样
	c = a + b;
	printf("%d+%d的值:%d", a, b, c);
}


int main()
{

	int a = 10;
	printf("hello.\n");
	printf("12+4= %d\n", 12 + 4);
	int b;
	printf("输个值\n");
	scanf_s("%d", &b);
	printf("%d-10的值为:%d\n", b, b - a);

	plus();
	getchar();
	return 0;
}

//定义时赋值叫做初始化如int p=0;

//a = b; 将b的值赋给a
//在程序中是个动作，在数学中是个关系(a=b和b=a在数学中意义一样)

//变量在被使用前(出现在了赋值号=的右边等)，应当进行一次赋值

//'='是赋值运算符，有运算符的式子叫做表达式

//c99不需要将定义变量放在最前


//两个整数运算结果只能是整数 
//10和10.0是两个不同的数
//浮点数和整数一起运算时，c会将整数转换成浮点数，然后进行浮点数的运算
//double %lf
//float %f
//int %d



//表达式是一系列 运算符和算子的组合，用来 计算一个值

//运算符(operator)是指进行运算的动作，如+ -
//算子(operand)是指参与运算的值，这个值可能是常数,变量,一个方法的返回值

//赋值是运算，也有结果
//a=6的结果是a被赋予的值，也就是6
//a=b=6 ---> a=(b=6)

//不要为了方便写嵌入式赋值--不利于阅读且容易产生错误

//exchange
//t = a;
//a = b;
//b = t;


//a+=b ---> a=a+b
//a-=b ---> a=a-b
//t/=(s+100)/2 ---> t= t/[(s+100)/2]
//t*=s+12 ---> t=t*(s+12)

//单目运算符 ,算子必须是个变量
//++
//--

//count++ 表达式的值是count原来的值
//++count 表达式的值是count+1以后的值
//不要组合到表达式当中，会看着很复杂



//关系运算符   优先级比算术运算符低比赋值运算符高
//== != <= >= > < 等等

//两个值的关系符合关系运算符的预期时，关系运算的结果
//为整数1,否则为整数0

//==和!=的优先级比其他的低，而连续的关系运算是从左到右进行的


//if (条件) 
//{
//	 做这些事情
//}

//没有else的话即使if中的不执行还是会执行接下来的所有代码


//if (条件) 
//{
//	做这些事情
//}
//else      //if中的条件不成立
//{
//	做这些事情
//}


//if(条件)      //条件 成立时
//{
//
//}
//else if (条件) 
//{
//	做这些事情
//}
//else 
//{
//
//}

//ifelse不套括号的话默认下一行(一句)是其执行语句



//else默认跟最近的else
//if else 是完整的一坨语句


//if只要求()里的值时0或非0


//tips
//即使只有一条语句的时候也加个{}


//int a=0;//switch的判断点(控制表达式)必须是int类型的
//int t=5;
//switch (a) 
//{
//case 1://a==1时
//	执行;
//	break;
//case 2://a==2时
//	执行;
//	break;
//case 1+2:
//	执行;
//	break;
//case t://c99才能用
//	执行;
//	break;
//default:
//	执行;
//	break;

//}
//break会让他离开switch语句




//while语句
//while (条件) //当条件满足时一直执行zx
//{
//	zx;//循环体
//}




//do 
//{
//
//} while (条件);
//会至少执行一次




//for (i = 1; i <= n; i++) 
//{
//
//}
//
//step:
//	i=1
//	i是否<=n
//	是的话执行循环体
//	i++
//	i是否<=n
//	是的话执行循环体

//对于一开始的i=1,当i<=n时，重复做循环体,每一轮循环
//在做完循环体内语句后,使得i++


//看for循环会有哪些数
//1到n有n-1+1个数
//0到n有n-0+1个数



//for循环和while循环是等价的
//可以互相改写



//for(;条件;)==while(条件)


//break离开一层for循环
//continue跳过剩下的循环体语句但不离开循环，进行下一次循环


//循环能嵌套


//接力break
//exit = 1;
//break;
//
//上一层循环
//if (exit) 
//{
//	break;
//}
//
//适用于多重循环跳出用goto蛮好
//goto out;
//
//out:
//return 0;





//c语言变量需定义

//整数，浮点数，逻辑，指针，自定义类型

//表达的数的范围:char<short<int<float<double


//sizeof
//是一个运算符，给出某个 类型或变量在内存中所占据的字节数
//如sizeof(int)    sizeof(i)


//char 1字节(8bit)
//short 2字节
//int 4字节 (一个寄存器大小  或32bit)
//long 8//64位机器,有不同的
//long long 8字节


//它是一个静态运算符，它的结果在编译时刻就决定了
//若在sizeof的括号内做运算，这些运算不会执行
//如sizeof(a++)，这里的a++不会执行
//int a = 6;
//sizeof(a+1.0)变为8，因为变为了double类型 


//%ld比%d可输出的数范围要大




//计算机内部一切都是二进制


//%x十六进制
//%o八进制


//整数类型多种的原因:
//	为了准确表达内存，做底层程序的需要
//	没有特殊需要，就选择int
//	现在的cpu普遍是32位或64位，一次内存读写就是
//	一个int，以此计算也是一个int，选择更短的类型
//	不会更快，甚至可能更慢
//
//	现在的编译器一般会设计内存对齐，所以更短的类型
//	实际在内存中有可能也占据一个int的大小(虽然
//	sizeof告诉你更小)
//
//	unsigned与否知识输出的不同，内部计算是一样的


//对整数类型:
//*****没有特殊需要，就选择int****


//浮点类型:
//	float  32字节
//	double 64字节






//%.3f   输出小数点后3位 (会四舍五入)



//float的表达

//a = 1.213f;   不写f是double


//选择浮点类型:
//	若无 特殊需要，用double
//	现代cpu能直接对double做硬件运算，性能不会比
//	float差，在64位的机器上，数据存储的速度也不
//	比float慢



//%c来输入输出字符 
//'1'  char
// 49 int

//ascii码


//%d %c
//有空格
//当读输入时 ，如123a，它将int类的123全读
//而a作为%c的读入

//%d%c
//没空格
//当读输入时，如123 a,它将把空格当作输入给%c




//类型转换
//当运算符的两边出现不一致的类型时，会自动转换成较大的类型
//大的意思是能表达的数的范围更大
//char --> short --> int --> long --> long long
//int --> float -->double

//对于printf，任何小于int的类型会被转换成int，
//float会被转换成double
//但时scanf不会，要明确知道后面的变量的大小，
//如要输入short，需要%hd


//强制类型转换(优先级高于四则运算)
//要把一个量强制转换成另一个类型(通常是较小的类型)
//(int)10.2



//bool

//1是true
//0是false




//! 逻辑非
//&& 逻辑与
//|| 逻辑或


//!age>0
//	逻辑运算符优先级小于算术运算符
//	但是单目元素符优先级大于双目
//	先做!age 若age为0则为1，若age不为0则为0
//	然后再判断是否>0





//i = 1 + 2, 3 + 4;
//得到i为3
//i = (1 + 2, 3 + 4);
//得到i为7




//函数
//一块代码，接收0个或多个参数，
//做一件事情，返回零个或一个值




void sum(int begin, int end)//函数头
//void为返回类型，无返回值时为void，
//sum为函数名，括号里的是参数表
{//{}里的是函数体
	int i;
	int sum = 0;
	for (i = begin; i <= end; i++)
	{
		sum += i;
	}
	printf("%d", sum);
}



//调用时:
//	函数名(参数值);
//没有参数也要有()
//若有参数，则需要给出正确的数量和顺序
//这些值会被按照顺序依次用来初始化函数中的参数
//函数定义在main函数之后的话需要在main函数前声明



//return停止函数的执行，并返回一个值
//return;
//return 表达式;//return后面是个表达式
//最好只有一个return，单一出口原则
//return(i)这样写很傻逼，不要这么写

//void 函数名(参数表)
//不能使用带值的return
//可以没return
//调用的时候不能做返回值的赋值 
//若函数有返回值，则必须使用带值的return 



//把函数写在上面是因为c的编译器自上而下顺序分析你的代码
//就比如说调用函数sum()
//在看到sun(1,10)时，需要知道sum()的样子，
//也就是sum()有几个参数，每个参数的类型如何，返回什么类型

// 声明:
//	将函数头放到main前面加个分号，构成了函数的原型
//函数原型的目的告诉编译器这个函数长什么样子 

//旧标准习惯把函数原型写在调用它的函数里，但现在一般写在
//调用它的函数前面
//原型可以不写参数的名字，但是一般仍然写上
//像void sum(int,int)，还是void sum(int a,int b)




//可以传递给函数的值是表达式的结果

//很多东西都是表达式
	//字面量，变量，函数返回值，计算结果..





//c语言在调用函数时，只能传值给函数，而不是那个变量 


//每个函数有自己的变量空间，参数也位于这个独立的空间
//和其他函数没有关系


//过去，对于函数参数表中的参数，叫做形式参数，调用函数时给的值，
//叫做实际参数。但由于容易让初学者误会实际参数就是实际在函数中
//进行计算的参数，误会调用函数的时候把变量而不是值传进去了，所以
//不建议继续用这种古老的方式称呼它们
//应该是参数和值的关系

//函数的每次运行，产生了一个独立的变量空间，在这个空间中的变量 ，是
//函数的这次运行所独有的，称作本地变量

//定义在函数内部的变量就是本地变量(局部变量)
//参数也是本地变量


//生存期:什么时候这个变量开始出现了，到什么时候它消亡了

//作用域:在(代码的)什么范围内可以访问这个变量(这个变量可以起作用)

//对于本地变量，这两个问题的答案是统一的:大括号内------块

//变量空间中的互不影响(我猜测)


/*本地变量是定义在块内的
它可以是定义在函数的块内
也可以定义在语句的块内
甚至可以随便拉一堆大括号来定义变量

程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量
就消失了*/

//块外面定义的变量在里面仍然有效 
//块里面定义了和外面同名的变量则掩盖了外面的
//不能再一个块内定义同名的变量
//本地变量不会被默认初始化
//参数在进入函数的时候被初始化了

//C语言不允许函数嵌套定义，可以在函数内放声明但不能在函数内
//定义另一个函数

//关于main
//int main()也是个函数
//return 0，返回0表示函数正常地运行完了




数组