//运算符&
//scanf("%d", &i); 里的&
//获得变量的地址，它的操作数必须是变量
//int i;
//printf("%x", &i);
//地址的大小是否与int相同取决于编译器
//int i;
//printf("%p", &i);
//&不能取对没有地址的东西取地址
//&(a+b)不能
//&(++a++)不能
//相邻的变量的地址可以//内存分配自顶向下，堆栈
//&的结果的sizeof，在32位和64位中不一样
//数组的地址
#include<stdio.h>
int main() {
	int i;
	int a[10];
	printf("%p\n", &a);
	printf("%p\n", a);
	printf("%p\n", &a[0]);//前三个输出结果相同
	printf("%p\n", &a[1]);//与上面差4位
	return 0;
}

//指针
//就是保存地址的变量
//int i;
//int* p = &i;//p指向i，p的值是i的地址，指针类型 的变量
//int *p, q;//*靠近int 或 变量 都一样，q一样只是个int变量

//变量的值是内存的地址
//普通变量的值是实际的值
//指针变量的值是具有实际值的变量的地址
//
//void(int *p);
//在被调用的时候得到了某个变量的地址：
//int i = 0; f(&i);
//在函数里面可以通过这个指针访问外面的这个i

//int *p = i;//p的值为i的地址，*p就是i
//访问地址上的变量*
//*是一个单目运算符，用来访问指针 的值所表示的地址 上的变量
//可以做左值也可以做右值
//int k = *p;访问 到了p指向的地址里的值
//*p = k + 1; 改变了p指向的地址里的值

//左值之所以叫左值
//是因为出现在赋值号左边的不是变量，而是值，是表达式计算的结果；
//a[0] = 2;
//*p = 3;（之前p需指向一个变量）
//是特殊的值，所以叫左值
//指针应用场景
//交换两个变量的值
//void swap(int *pa, int *pb)//pa,pb都是用来指向地址的变量,表示指针变量
//int t = *pa;
//*pa = *pb;
//*pb = t;//跟之前的一样，其实是值交换
//函数返回多个值，某些值就只能通过指针返回
//传入的参数实际上是需要保存带回的结果的变量
//函数返回运算的状态，结果通过指针返回
//常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错：
//	-1或0（在文件操作会看到大量的例子）
//	但是当任何数值都是有效的可能结果时，就得分开返回
	//后续的语言(C++,Java)采用了异常机制来解决这个问题

//常见错误
//定义了指针变量，还没有指向任何变量，就开始使用指针
//int *p=12;错
//int *p;
//*p = 12;错
//int *p = &i;
//*p = 12;
//int *p后可接 = &变量;
//其实就是接一个地址
//int * 说明p是一个指针变量
//=后的东西是p指向的东西
//若没有int 说明*p是访问p所指的地址中的值
//是有int时的&后面的变量的值

//传入函数的数组成了什么
//void aaa(int a[]) a[]实际是一个指针
//函数参数表中的数组实际是指针，但是可以用数组的运算符[]进行运算
//sizeof(a) == sizeof(int*)

//数组参数
//以下四种函数原型是等价的
//int sum(int *ar, int n);
//int sum(int *, int);
//int sum(int ar[], int n);
//int sum(int[], int);
//注:出现在参数表中时是等价的
//数组变量是特殊的指针
//数组变量本身表达地址(取地址符时，数组的地址可以不加&符号，直接拿数组变量的名字就可以
//得到数组的地址)
//所以 int a[10]; int* p = a;//无需用&取地址
//但是数组的单元表达的是变量，需要用&取地址
//a == &a[0];
//[]运算符可以对数组做，也可以对指针做
//p[0]<==>a[0]
//p[0]可以看作p所指的地址当作一个数组后里面的的第一个单元格(p已经指向一个地址后)
//运算符可以对指针做，也可以对数组做：
//*a = 25;
//
//数组变量是const的指针(常量指针)，所以不能被赋值
//int a[] <= = > int * const a = ..
//int b[] = a;是不行的


//指针与const
//指针--可以是const
//值--可以是const
//
//指针是const
//表示一旦得到了某个变量的地址，不能再指向其他变量
//int *const q = &i;//q是const
//*q = 26;//OK
//q++;//ERROR
//
//
//所指的const
//表示不能通过这个指针去修改那个变量(并不能使得那个变量成为const)
//不能通过p去赋值，不能通过p去修改i
//const int *p = &i;
//*p = 26;//ERROR (*p)是const
//i = 26;//OK
//p = &j;//OK

//int i;
//const int*p1=&i;
//int const * p2 = &i;
//int *const p3 = &i;
//判断哪个被const了的标志，是const加在*的前面还是后面

//总是可以把一个非const的值转换为const的


//当要传递的参数的类型比地址大的时候，这是常用的手段：
//既能用比较少的字节数传递值给参数，又能避免函数对外面的变量的修改


//const数组
//const int a[] = { 1,2,3,4,5,6 };
//数组变量已经是const的指针了，这里的const表明数组的每个单元都是 const int
//所以必须通过初始化进行赋值



//保护数组值
//因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值
//为了保护数组不被函数破坏，可以设置参数为const
//int sum(const int a[], int length);