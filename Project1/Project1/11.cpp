//运算符&
//scanf("%d", &i); 里的&
//获得变量的地址，它的操作数必须是变量
//int i;
//printf("%x", &i);
//地址的大小是否与int相同取决于编译器
//int i;
//printf("%p", &i);
//&不能取对没有地址的东西取地址
//&(a+b)不能
//&(++a++)不能
//相邻的变量的地址可以//内存分配自顶向下，堆栈
//&的结果的sizeof，在32位和64位中不一样
//数组的地址
#include<stdio.h>
int main() {
	int i;
	int a[10];
	printf("%p\n", &a);
	printf("%p\n", a);
	printf("%p\n", &a[0]);//前三个输出结果相同
	printf("%p\n", &a[1]);//与上面差4位
	return 0;
}

//指针
//就是保存地址的变量
//int i;
//int* p = &i;//p指向i，p的值是i的地址，指针类型 的变量
//int *p, q;//*靠近int 或 变量 都一样，q一样只是个int变量

//变量的值是内存的地址
//普通变量的值是实际的值
//指针变量的值是具有实际值的变量的地址
//
//void(int *p);
//在被调用的时候得到了某个变量的地址：
//int i = 0; f(&i);
//在函数里面可以通过这个指针访问外面的这个i

//int *p = i;//p的值为i的地址，*p就是i
//访问地址上的变量*
//*是一个单目运算符，用来访问指针 的值所表示的地址 上的变量
//可以做左值也可以做右值
//int k = *p;访问 到了p指向的地址里的值
//*p = k + 1; 改变了p指向的地址里的值

//左值之所以叫左值
//是因为出现在赋值号左边的不是变量，而是值，是表达式计算的结果；
//a[0] = 2;
//*p = 3;（之前p需指向一个变量）
//是特殊的值，所以叫左值
//指针应用场景
//交换两个变量的值
//void swap(int *pa, int *pb)//pa,pb都是用来指向地址的变量,表示指针变量
//int t = *pa;
//*pa = *pb;
//*pb = t;//跟之前的一样，其实是值交换
//函数返回多个值，某些值就只能通过指针返回
//传入的参数实际上是需要保存带回的结果的变量
//函数返回运算的状态，结果通过指针返回
//常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错：
//	-1或0（在文件操作会看到大量的例子）
//	但是当任何数值都是有效的可能结果时，就得分开返回
	//后续的语言(C++,Java)采用了异常机制来解决这个问题

//常见错误
//定义了指针变量，还没有指向任何变量，就开始使用指针
//int *p=12;错
//int *p;
//*p = 12;错
//int *p = &i;
//*p = 12;
//int *p后可接 = &变量;
//其实就是接一个地址
//int * 说明p是一个指针变量
//=后的东西是p指向的东西
//若没有int 说明*p是访问p所指的地址中的值
//是有int时的&后面的变量的值

//传入函数的数组成了什么
//void aaa(int a[]) a[]实际是一个指针
//函数参数表中的数组实际是指针，但是可以用数组的运算符[]进行运算
//sizeof(a) == sizeof(int*)

//数组参数
//以下四种函数原型是等价的
//int sum(int *ar, int n);
//int sum(int *, int);
//int sum(int ar[], int n);
//int sum(int[], int);
//注:出现在参数表中时是等价的
//数组变量是特殊的指针
//数组变量本身表达地址(取地址符时，数组的地址可以不加&符号，直接拿数组变量的名字就可以
//得到数组的地址)
//所以 int a[10]; int* p = a;//无需用&取地址
//但是数组的单元表达的是变量，需要用&取地址
//a == &a[0];
//[]运算符可以对数组做，也可以对指针做
//p[0]<==>a[0]
//p[0]可以看作p所指的地址当作一个数组后里面的的第一个单元格(p已经指向一个地址后)
//运算符可以对指针做，也可以对数组做：
//*a = 25;


//数组变量是const的指针(常量指针)，所以不能被赋值
//int a[] <= = > int * const a = ..
//int b[] = a;是不行的


//指针与const
//指针--可以是const
//值--可以是const
//
//指针是const
//表示一旦得到了某个变量的地址，不能再指向其他变量
//int *const q = &i;//q是const
//*q = 26;//OK
//q++;//ERROR
//
//
//所指的const
//表示不能通过这个指针去修改那个变量(并不能使得那个变量成为const)
//不能通过p去赋值，不能通过p去修改i
//const int *p = &i;
//*p = 26;//ERROR (*p)是const
//i = 26;//OK
//p = &j;//OK

//int i;
//const int*p1=&i;
//int const * p2 = &i;
//int *const p3 = &i;
//判断哪个被const了的标志，是const加在*的前面还是后面

//总是可以把一个非const的值转换为const的


//当要传递的参数的类型比地址大的时候，这是常用的手段：
//既能用比较少的字节数传递值给参数，又能避免函数对外面的变量的修改


//const数组
//const int a[] = { 1,2,3,4,5,6 };
//数组变量已经是const的指针了，这里的const表明数组的每个单元都是 const int
//所以必须通过初始化进行赋值



//保护数组值
//因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值
//为了保护数组不被函数破坏，可以设置参数为const
//int sum(const int a[], int length);


//p+1,下一个地址
//char 差1，int差4
//加了一个sizeof

//char ac[] = { 0,1,2,3,4,5,6,7,8,9 };
//char *p = ac;

//*p  -> ac[0]
//*(p+1)  -> ac[1]
//*(p + n) < ->ac[n]

//给一个指针加I表示要让指针指向下一个变量
//int a[10];
//int *p = a;
//*(p+i)--->a[i]
//如果指针不是指向一片连续分配的空间，如数组，则这种运算没有意义‘


//可以对指针做的算术运算
//给指针加、减一个 整数(+,+=,-,-=)两个指针相加减，给的是得到 的结果除以sizeof
//递增递减(++/--)


//*p++ ---->*(p++),因为++比*的优先级高


//指针比较<,<=,=,>,>=,!= 都可以对指针做
//比较它们在内存中的地址
//数组当中的单元的地址肯定是线性递增的


//0地址
//内存中有0地址, 但是0地址通常是一个不能随便碰的地址
//所以指针不应该有0值
//因此可以用0地址来表示特殊的事情
//如返回的指针是无效的
//如指针没有被真正初始化(先初始化为0)
//NULL(必须全部大写)是一个预定定于的符号, 表示0地址, 建议都用NULL如果 想要用到0地址
//有的编译器不愿意我用0来表示0地址

//指针类型
//无论指向什么类型, 所有的指针的大小都是一样的, 因为都是地址
//但是指向不同类型的指针是不能直接互相赋值的
//这是为了避免用错指针


//指针的类型转换
//void*表示不知道指向什么东西的指针
//计算时与char*相同(但不相通)
//指针也可以转换类型
//int *p = &i; void *q = (void *)p;
//这并没有改变p所指的变量的类型,而是让后人用不同的眼光通过p看它所指的变量


//指针作用总结
//需要传入较大的数据时用做参数
//传入数组后对数组做操作
//函数返回不止一个结果
//需要用函数来修改不止一个变量
//动态申请的内存



//动态内存分配
//如果输入数据时,想得知个数,然后输入,记录每个数据 
//c99可以用变量做数组定义的大小
int n = 10;
int* a = (int*)malloc(n * sizeof(int));

#include<stdio.h>
#include<stdlib.h>


int main(void) 
{
	int number;
	int* a;
	int i;
	printf("输入数量:");
	scanf("%d", &number);
	//int a[number];  如果是c99可以这么用
	a = (int*)malloc(number * sizeof(int));
	//右括号内为占据的空间,malloc 返回的结果时void*,所以左括号内为int*
	//之后就把a当数组用,a[number]
	for (i = 0; i < number; i++)
	{
		scanf("%d", &a[i]);
	}
	for (i = 0; i <= number - 1; i++)
	{
		printf("%d", a[i]);
	}
	free(a);//malloc后要free,有借有还
	return 0;
}


//void* malloc(size_t size);
//向malloc 申请的空间的大小是以字节为单位的
//
//返回的结果(类型)是void*, 需要类型转换成自己需要的类型
//
//(int*)malloc(n * sizeof(int));若果要int右边就数量*sizeof(int)
//其实是要int的所需的空间 ,或者说就是要多少的空间,可以是malloc(100*1024*1024)
//内存是空间,不管int double等等,我要拿它当XXX,

//若申请 失败则返回0,或者叫做NULL



//free()
//把申请得来的空间还给"系统"
//申请过的空间,最终都应该要还
//"出来混,迟早要还"
//只能还申请来的空间的首地址,就是p++,p=&i啥的后不能free
//free(NULL)可以,因为0不可能是个有效的地址,free时会先判断如果给NULL就不做事情了
//free(1)不对,肯定不对
//操作系统的机制是会将运行完的程序曾经使用过的内存全被清除干净
//常见问题
//申请了每free--->长时间运行内存逐渐下降
//新手:忘了...
//老手:找不到合适的free的时机
//free 过了又free会炸
//地址变过来,直接去free